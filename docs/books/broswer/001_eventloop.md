# EventLoop 问题分解

::: tip
以下内容包括：进程，线程，浏览器进程，浏览器EventLoop，Node EventLoop.
:::

## 进程，线程
### 线程 问题
- 线程是 CPU调度的最小单位
- 一个进程可以包括多个线程，这些线程共享这个进程的资源
### 进程 问题
- 1、CPU承担了所有的计算任务，进程是CPU资源分配的最小单位
- 2、在同一个时间内，单个CPU只能执行一个任务，只能运行一个进程
- 3、如果有一个进程正在执行，其它进程就得暂停
- 4、CPU使用了时间片轮转的算法实现多进程的调度

## chrome浏览器进程 包括哪些进程？
- 浏览器是多进程的
- 每一个TAB页就是一个进程
- 1、浏览器主进程（控制其它子进程的创建和销毁，浏览器界面显示，比如用户交互、前进、后退等操作，将渲染的内容绘制到用户界面上）
- 2、渲染进程（就是我们说的浏览器内核，负责页面的渲染、脚本执行、事件处理，每个TAB页都有一个渲染进程）
- 3、网络进程（处理网络请求、文件访问等操作）
- 4、GPU进程（用于3D绘制）
- 5、第三方插件进程

#### 渲染进程

- 1、GUI渲染线程（渲染、布局和绘制页面，当页面需要重绘和回流时，此线程就会执行，与JS引擎互斥）
- 2、JS引擎线程（负责解析执行JS脚本，只有一个JS引擎线程(单线程)，与GUI渲染线程互斥）
- 3、事件触发线程（用来控制事件循环(鼠标点击、setTimeout、Ajax等)，当事件满足触发条件时，把事件放入到JS引擎所有的执行队列中）
- 4、定时器触发线程（setInterval和setTimeout所在线程，定时任务并不是由JS引擎计时，而是由定时触发线程来计时的，计时完毕后会通知事件触发线程）
- 5、异步HTTP请求线程（浏览器有一个单独的线程处理AJAX请求，当请求完毕后，如果有回调函数，会通知事件触发线程）
## 浏览器EventLoop使用
![An image](/browser/browser_event_loop.png)

### 宏任务
- 页面的大部分任务是在主任务上执行的，比如下面这些都是宏任务
- 渲染事件(DOM解析、布局、绘制)， 用户交互(鼠标点击、页面缩放)，JavaScript脚本执行，网络请求，文件读写
- 宏任务会添加到消息到消息队列的尾部，当主线程执行到该消息的时候就会执行
- 每次从事件队列中获取一个事件回调并且放到执行栈中的就是一个宏任务，宏任务执行过程中不会执行其它内容
- 每次宏任务执行完毕后会进行GUI渲染线程的渲染，然后再执行下一个宏任务
- 宏任务: script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering
- 宏任务颗粒度较大，不适合需要精确控制境的任务
- 宏任务是由宿主方控制的

### 微任务
- 宏任务结束后会进行渲染然后执行下一个宏任务
- 微任务是当前宏任务执行后立即执行的宏任务
- 当宏任务执行完，就到达了检查点,会先将执行期间所产生的所有微任务都执行完再去进行渲染
- 微任务是由V8引擎控制的，在创建全局执行上下文的时候，也会在V8引擎内部创建一个微任务队列
- 微任务: process.nextTick（Nodejs）, Promises, Object.observe, MutationObserver
#### promise：
 - 微任务队列会一次性清空
 - 微任务会先于渲染执行
 - 宏任务结束之后会先执行微任务 

#### MutationObserver #
- MutationObserver创建并返回一个新的 MutationObserver 它会在指定的DOM发生变化时被调用
MutationObserver采用了异步 + 微任务的方案
- 异步是为了提升同步操作带来的性能问题
- 微任务是为了解决实时响应的问题